

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <sstream>
#include <string>
#include <algorithm>

enum TagName{
    TOKEN = 0,
    FUNCTION,
    FUNCTION_HEADER,
    FUNCTION_BODY,
    COMPOUND_STATEMENT,
    EXPRESSION_STATEMENT,
    FOR_TOKEN,
    FOR_HEADER,
    IF_TOKEN,
    IF_HEADER,
    IF_PART_STATEMENT,
    ELSE_TOKEN,
    IF_ELSE_STATEMENT,
    WHILE_TOKEN,
    WHILE_HEADER,
    SWITCH_STATEMENT,
    DO_WHILE_STATEMENT,
    IF_CONDITION,
    ELSE_PART_STATEMENT,
    FOR_LOOP,
    WHILE_LOOP,
    PREPROCDIRECTIVE
};

typedef struct stackElement{
    TagName tag;
    std::string    id;
    int     indexInLine;
    int     startLine;
    int     endLine;
    int     minLeftCol;
    int     maxRightCol;
}stackElement;




std::vector<stackElement> xmlTree;

size_t len = 0;
int lineLength;
std::string fileName;
/**
 ** Takes the output file generated by parsing the
 ** testfile.c using lex and yacc.
 ** Completed -> IF, FOR, FUNCTION, COMPOUND
**/
void makeXML(){
    std::ostringstream childXMLTree;
    int lineStart, lineEnd, minLeft, maxRight;
    lineStart = 1000000;
    lineEnd = 0;
    minLeft = 1000000;
    maxRight = 0;

    for(std::vector<stackElement>::iterator it = xmlTree.begin(); it != xmlTree.end(); it++){
        lineStart = std::min(lineStart, it->startLine);
        lineEnd = std::max(lineEnd, it->endLine);
        minLeft = std::min(minLeft, it->minLeftCol);
        maxRight = std::max(maxRight, it->maxRightCol);
        switch(it->tag){
            case FUNCTION:  {
                childXMLTree << "<Function LineStart=\"" << it->startLine << "\" ";
                childXMLTree << "LineEnd=\"" << it->endLine << "\" ";
                childXMLTree << "MinLeftCol=\"" << it->minLeftCol << "\" ";
                childXMLTree << "MaxRightCol=\"" << it->maxRightCol << "\" >" << std::endl;
                childXMLTree << it->id;
                childXMLTree << "</Function>" << std::endl;
                break;
            }
            case TOKEN: {
                childXMLTree << "<Token LineStart=\"" << it->startLine << "\" ";
                childXMLTree << "LineEnd=\"" << it->endLine << "\" ";
                childXMLTree << "Index=\"" << it->indexInLine << "\" ";
                childXMLTree << "MinLeftCol=\"" << it->minLeftCol << "\" ";
                childXMLTree << "MaxRightCol=\"" << it->maxRightCol << "\" > " << it->id << " </Token>" << std::endl;
                break;
            }
            case PREPROCDIRECTIVE: {
                childXMLTree << "<PreprocDirective LineStart=\"" << it->startLine << "\" ";
                childXMLTree << "LineEnd=\"" << it->endLine << "\" ";
                childXMLTree << "MinLeftCol=\"" << it->minLeftCol << "\" ";
                childXMLTree << "MaxRightCol=\"" << it->maxRightCol << "\" >" << std::endl;
                childXMLTree << it->id;
                childXMLTree << "</PreprocDirective>" << std::endl;
                break;
            }
        }
    }

    std::cout << std::endl;
    std::cout << "<File Name=\"" << fileName << "\" ";
    std::cout << "LineStart=\"" << lineStart << "\" ";
    std::cout << "LineEnd=\"" << lineEnd << "\" ";
    std::cout << "MinLeftCol=\"" << minLeft << "\" ";
    std::cout << "MaxRightCol=\"" << maxRight << "\" > ";
    std::cout << childXMLTree.str();
    std::cout << " </File>" << std::endl;

    std::cout << std::endl;
}

void printError(std::string er){
    std::cout << er << std::endl;
    std::cout << "Exiting..." << std::endl << std::endl;
}

int main(int argc, char const *argv[]) {

    if(argc != 2){
        printError("Error: No input file.");
        return 0;
    }
    std::ifstream inputFile(argv[1]);

    if(!inputFile){
        printError("Error: No input file.");
        return 0;
    }

    std::string currentLine;
    // int liner = 0;
    std::getline(inputFile, currentLine);
    fileName += currentLine;

    int currentTokenLineNumber, previousTokenLineNumber = -1;
    int indexInCurrentLine;

    while (std::getline(inputFile, currentLine))
    {
        // liner++;
        std::istringstream currentLineBuffer(currentLine);
        std::string tagType, skipInput;
        currentLineBuffer >> tagType;
        int integer;
        stackElement newStackElement;

        if(tagType.compare("Token:") == 0){
            int startOfToken = currentLine.find_first_of('\"');
            int endOfToken = currentLine.find_last_of('\"');
            tagType = currentLine.substr(startOfToken, endOfToken - startOfToken + 1);
            currentLine = currentLine.substr(endOfToken+2,currentLine.length() - endOfToken - 2);

            std::istringstream currentLineBufferForToken(currentLine);
            //Token: "int"  => Line: 5 StartColumn: 1 EndColumn: 3

            // &lt;	    <	less than
            // &gt;	    >	greater than
            // &amp;	&	ampersand
            // &apos;	'	apostrophe
            // &quot;	"	quotation mark

            std::string tokenID;
            for(int index = 0; index < tagType.length(); index++){
                switch (tagType[index]) {
                    case '<'    :   tokenID += "&lt;";    break;
                    case '>'    :   tokenID += "&gt;";    break;
                    case '&'    :   tokenID += "&amp;";    break;
                    case '\''   :   tokenID += "&apos;";    break;
                    case '\"'   :   tokenID += "&quot;";    break;
                    default     :   tokenID += tagType[index];
                }
            }
            newStackElement.tag = TOKEN;
            newStackElement.id  = tokenID;

            currentLineBufferForToken >> skipInput >> skipInput;
            currentLineBufferForToken >> integer;
            newStackElement.startLine = integer;
            newStackElement.endLine = integer;
            currentTokenLineNumber = integer;
            currentLineBufferForToken >> skipInput;
            currentLineBufferForToken >> integer;
            newStackElement.minLeftCol = integer;

            currentLineBufferForToken>>skipInput;
            currentLineBufferForToken >> integer;
            newStackElement.maxRightCol = integer;

            if(currentTokenLineNumber != previousTokenLineNumber){
                indexInCurrentLine = 0;
                previousTokenLineNumber = currentTokenLineNumber;
            }
            else{
                indexInCurrentLine += 1;
            }
            newStackElement.indexInLine = indexInCurrentLine;
            xmlTree.push_back(newStackElement);

        }
        else if(tagType.compare("FunctionHeader:") == 0){
            //FunctionHeader:	=> StartLine: 5 StartColumn: 1 EndLine: 5 EndColumn: 11
            newStackElement.tag = FUNCTION_HEADER;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.startLine = integer;

            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            int startcolumn = integer;

            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.endLine = integer;

            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            int endColumn = integer;

            stackElement leftBrace = xmlTree.back();
            xmlTree.pop_back();

            std::vector<stackElement> tempXMLTree;
            stackElement lastElement;
            int min=100000000, max=0;

            while(1){
                if(xmlTree.empty()) break;
                lastElement = xmlTree.back();
                if((lastElement.startLine > newStackElement.startLine) || ((lastElement.startLine == newStackElement.startLine) && (lastElement.minLeftCol >= startcolumn))){
                    if(lastElement.minLeftCol < min){
                        min = lastElement.minLeftCol;
                    }

                    if(lastElement.maxRightCol > max){
                        max = lastElement.maxRightCol;
                    }
                    tempXMLTree.push_back(lastElement);
                    xmlTree.pop_back();
                }
                else break;
            }

            newStackElement.minLeftCol = min;
            newStackElement.maxRightCol = max;

            std::ostringstream childXMLTree;
            std::reverse(tempXMLTree.begin(), tempXMLTree.end());

            for (std::vector<stackElement>::iterator i = tempXMLTree.begin(); i != tempXMLTree.end(); i++) {
                childXMLTree << "<Token LineStart=\"" << i->startLine << "\" ";
                childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                childXMLTree << "Index=\"" << i->indexInLine << "\" ";
                childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" > " << i->id << " </Token>" << std::endl;
            }
            newStackElement.id = childXMLTree.str();
            xmlTree.push_back(newStackElement);
            xmlTree.push_back(leftBrace);
        }
        else if(tagType.compare("Preprocessor:") == 0){
            //Preprocessor:	=> StartLine: 1 StartColumn: 1 EndLine: 1 EndColumn: 19
            newStackElement.tag = PREPROCDIRECTIVE;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.startLine = integer;

            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            int startcolumn = integer;

            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.endLine = integer;

            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            int endColumn = integer;

            std::vector<stackElement> tempXMLTree;
            stackElement lastElement;
            int min=100000000, max=0;

            while(1){
                if(xmlTree.empty()) break;
                lastElement = xmlTree.back();
                if((lastElement.startLine > newStackElement.startLine) || ((lastElement.startLine == newStackElement.startLine) && (lastElement.minLeftCol >= startcolumn))){
                    if(lastElement.minLeftCol < min){
                        min = lastElement.minLeftCol;
                    }

                    if(lastElement.maxRightCol > max){
                        max = lastElement.maxRightCol;
                    }
                    tempXMLTree.push_back(lastElement);
                    xmlTree.pop_back();
                }
                else break;
            }

            newStackElement.minLeftCol = min;
            newStackElement.maxRightCol = max;

            std::ostringstream childXMLTree;
            std::reverse(tempXMLTree.begin(), tempXMLTree.end());

            for (std::vector<stackElement>::iterator i = tempXMLTree.begin(); i != tempXMLTree.end(); i++) {
                childXMLTree << "<Token LineStart=\"" << i->startLine << "\" ";
                childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                childXMLTree << "Index=\"" << i->indexInLine << "\" ";
                childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" > " << i->id << " </Token>" << std::endl;
            }
            newStackElement.id = childXMLTree.str();
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("ExpressionStatement:") == 0){
            //ExpressionStatement:	=> StartLine: 15 StartColumn: 9 EndLine: 15 EndColumn: 15

            newStackElement.tag = EXPRESSION_STATEMENT;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.startLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            int startcolumn = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.endLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            int endColumn = integer;
            std::vector<stackElement> tempXMLTree;
            stackElement lastElement;
            int min=100000000, max=0;
            while(1){
                if(xmlTree.empty()) break;
                lastElement = xmlTree.back();
                if((lastElement.startLine > newStackElement.startLine) || ((lastElement.startLine == newStackElement.startLine) && (lastElement.minLeftCol >= startcolumn))){
                    if(lastElement.minLeftCol < min){
                        min = lastElement.minLeftCol;
                    }

                    if(lastElement.maxRightCol > max){
                        max = lastElement.maxRightCol;
                    }
                    tempXMLTree.push_back(lastElement);
                    xmlTree.pop_back();
                }
                else break;
            }

            newStackElement.minLeftCol = min;
            newStackElement.maxRightCol = max;
            std::ostringstream childXMLTree;
            std::reverse(tempXMLTree.begin(), tempXMLTree.end());

            for (std::vector<stackElement>::iterator i = tempXMLTree.begin(); i != tempXMLTree.end(); i++) {
                childXMLTree << "<Token LineStart=\"" << i->startLine << "\" ";
                childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                childXMLTree << "Index=\"" << i->indexInLine << "\" ";
                childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" > " << i->id << " </Token>" << std::endl;
            }
            newStackElement.id = childXMLTree.str();
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("IfStatementStart:") == 0){
            //IfStatement:	=> StartLine: 10 StartColumn: 5
            newStackElement.tag = IF_TOKEN;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.startLine = integer;
            newStackElement.endLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.minLeftCol = integer;
            newStackElement.maxRightCol = integer + 1;
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("IfHeader:") == 0){
            //Assuming there are no assignment statements inside the if condition
            //IfHeader:	=> EndLine: 10 EndColumn: 14

            newStackElement.tag = IF_HEADER;
            currentLineBuffer >> tagType >> tagType;
            currentLineBuffer >> integer;
            newStackElement.endLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;

            std::vector<stackElement> tempXMLTree;
            stackElement lastElement;
            int min=100000000, max=0;
            max = integer;
            while(1){
                if(xmlTree.empty()) break;
                lastElement = xmlTree.back();
                if(lastElement.tag != IF_TOKEN){
                    if(lastElement.minLeftCol < min){
                        min = lastElement.minLeftCol;
                    }

                    if(lastElement.maxRightCol > max){
                        max = lastElement.maxRightCol;
                    }
                    tempXMLTree.push_back(lastElement);
                    xmlTree.pop_back();
                }
                else{
                    newStackElement.startLine = lastElement.startLine;
                    xmlTree.pop_back();
                    break;
                }
            }

            newStackElement.minLeftCol = min;
            newStackElement.maxRightCol = max;

            std::ostringstream childXMLTree;
            std::reverse(tempXMLTree.begin(), tempXMLTree.end());

            for (std::vector<stackElement>::iterator i = tempXMLTree.begin(); i != tempXMLTree.end(); i++) {
                childXMLTree << "<Token LineStart=\"" << i->startLine << "\" ";
                childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                childXMLTree << "Index=\"" << i->indexInLine << "\" ";
                childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" > "<< i->id <<" </Token>" << std::endl;
            }
            newStackElement.id = childXMLTree.str();
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("CompoundStatement:") == 0){
            //CompoundStatement:	=> StartLine: 11 EndLine: 13

            newStackElement.tag = COMPOUND_STATEMENT;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.startLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.endLine = integer;
            std::vector<stackElement> tempXMLTree;
            stackElement lastElement;
            int min=100000000, max=0;
            while(1){
                if(xmlTree.empty()) break;
                lastElement = xmlTree.back();
                if(lastElement.minLeftCol < min){
                    min = lastElement.minLeftCol;
                }

                if(lastElement.maxRightCol > max){
                    max = lastElement.maxRightCol;
                }
                tempXMLTree.push_back(lastElement);
                xmlTree.pop_back();
                if(lastElement.tag == TOKEN){
                    if(lastElement.id.compare("&quot;{&quot;") == 0){
                        break;
                    }
                }
            }

            newStackElement.minLeftCol = min;
            newStackElement.maxRightCol = max;
            std::ostringstream childXMLTree;
            std::reverse(tempXMLTree.begin(), tempXMLTree.end());

            for (std::vector<stackElement>::iterator i = tempXMLTree.begin(); i != tempXMLTree.end(); i++) {
                switch(i->tag){
                    case TOKEN: {
                        childXMLTree << "<Token LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "Index=\"" << i->indexInLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" > " << i->id << " </Token>" << std::endl;
                        break;
                    }
                    case COMPOUND_STATEMENT: {
                        childXMLTree << "<CompoundStatement LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" <<i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</CompoundStatement>" << std::endl;
                        break;
                    }
                    case EXPRESSION_STATEMENT: {
                        childXMLTree << "<ExpressionStatement LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</ExpressionStatement>" << std::endl;
                        break;
                    }
                    case FOR_LOOP: {
                        childXMLTree << "<ForLoop LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</ForLoop>" << std::endl;
                        break;
                    }
                    case IF_CONDITION: {
                        childXMLTree << "<IfCondition LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</IfCondition>" << std::endl;
                        break;
                    }
                    case WHILE_LOOP: {
                        childXMLTree << "<WhileLoop LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</WhileLoop>" << std::endl;
                        break;
                    }
                    default: {
                        childXMLTree << "<Unindentified> " << i->id << " </Unindentified>" << std::endl;
                    }
                }
            }
            newStackElement.id = childXMLTree.str();
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("IfPartOfStatement:") == 0){
            //IfPartOfStatement:	=> EndLine: 13 EndColumn: 6

            newStackElement.tag = IF_PART_STATEMENT;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.endLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;

            std::vector<stackElement> tempXMLTree;
            stackElement lastElement;
            int min=100000000, max=0;
            max = integer;
            while(1){
                if(xmlTree.empty()) break;
                lastElement = xmlTree.back();

                if(lastElement.minLeftCol < min){
                    min = lastElement.minLeftCol;
                }

                if(lastElement.maxRightCol > max){
                    max = lastElement.maxRightCol;
                }

                tempXMLTree.push_back(lastElement);
                xmlTree.pop_back();
                if(lastElement.tag == IF_HEADER){
                    newStackElement.startLine = lastElement.startLine;
                    break;
                }
            }
            newStackElement.minLeftCol = min;
            newStackElement.maxRightCol = max;

            std::ostringstream childXMLTree;
            std::reverse(tempXMLTree.begin(), tempXMLTree.end());

            for (std::vector<stackElement>::iterator i = tempXMLTree.begin(); i != tempXMLTree.end(); i++) {
                switch(i->tag){
                    case TOKEN: {
                        childXMLTree << "<Token LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "Index=\"" << i->indexInLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" > " << i->id << " </Token>" << std::endl;
                        break;
                    }
                    case COMPOUND_STATEMENT: {
                        childXMLTree << "<CompoundStatement LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</CompoundStatement>" << std::endl;
                        break;
                    }
                    case EXPRESSION_STATEMENT: {
                        childXMLTree << "<ExpressionStatement LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</ExpressionStatement>" << std::endl;
                        break;
                    }
                    case FOR_LOOP: {
                        childXMLTree << "<ForLoop LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</ForLoop>" << std::endl;
                        break;
                    }
                    case IF_CONDITION: {
                        childXMLTree << "<IfCondition LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</IfCondition>" << std::endl;
                        break;
                    }
                    case WHILE_LOOP: {
                        childXMLTree << "<WhileLoop LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</WhileLoop>" << std::endl;
                        break;
                    }
                    case IF_HEADER: {
                        childXMLTree << "<IfHeader LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</IfHeader>" << std::endl;
                        break;
                    }
                }

            }
            newStackElement.id = childXMLTree.str();
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("IfStatementEnd:") == 0){
            stackElement lastElement = xmlTree.back();
            xmlTree.pop_back();
            xmlTree.back().tag = IF_CONDITION;
            xmlTree.push_back(lastElement);
        }
        else if(tagType.compare("ElseStatement:") == 0){
            //ElseStatement:	=> StartLine: 14 StartColumn: 5
            newStackElement.tag = ELSE_TOKEN;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.startLine = integer;
            newStackElement.endLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.minLeftCol = integer;
            newStackElement.maxRightCol = integer + 3;
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("If-ElseStatement:") == 0){
            //If-ElseStatement:	=> EndLine: 16 EndColumn: 6

            stackElement elseIfXMLTree;

            elseIfXMLTree.tag = ELSE_PART_STATEMENT;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            elseIfXMLTree.endLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;

            std::vector<stackElement> tempXMLTree;
            stackElement lastElement;
            int min=100000000, max=0;
            max = integer;
            while(1){
                if(xmlTree.empty()) break;
                lastElement = xmlTree.back();

                if(lastElement.tag != ELSE_TOKEN){
                    if(lastElement.minLeftCol < min){
                        min = lastElement.minLeftCol;
                    }

                    if(lastElement.maxRightCol > max){
                        max = lastElement.maxRightCol;
                    }
                    tempXMLTree.push_back(lastElement);
                    xmlTree.pop_back();
                }
                else{
                    elseIfXMLTree.startLine = lastElement.startLine;
                    xmlTree.pop_back();
                    break;
                }
            }
            elseIfXMLTree.minLeftCol = min;
            elseIfXMLTree.maxRightCol = max;

            std::ostringstream childXMLTree;
            std::reverse(tempXMLTree.begin(), tempXMLTree.end());

            for (std::vector<stackElement>::iterator i = tempXMLTree.begin(); i != tempXMLTree.end(); i++) {
                switch(i->tag){
                    case TOKEN: {
                        childXMLTree << "<Token LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "Index=\"" << i->indexInLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" > " << i->id << " </Token>" << std::endl;
                        break;
                    }
                    case COMPOUND_STATEMENT: {
                        childXMLTree << "<CompoundStatement LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</CompoundStatement>" << std::endl;
                        break;
                    }
                    case EXPRESSION_STATEMENT: {
                        childXMLTree << "<ExpressionStatement LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</ExpressionStatement>" << std::endl;
                        break;
                    }
                    case FOR_LOOP: {
                        childXMLTree << "<ForLoop LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</ForLoop>" << std::endl;
                        break;
                    }
                    case IF_CONDITION: {
                        childXMLTree << "<IfCondition LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</IfCondition>" << std::endl;
                        break;
                    }
                    case WHILE_LOOP: {
                        childXMLTree << "<WhileLoop LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</WhileLoop>" << std::endl;
                        break;
                    }
                }

            }
            elseIfXMLTree.id = childXMLTree.str();

            stackElement ifXMLTree = xmlTree.back();


            newStackElement.tag = IF_CONDITION;
            newStackElement.startLine = ifXMLTree.startLine;
            newStackElement.endLine = elseIfXMLTree.endLine;
            newStackElement.minLeftCol = std::min(ifXMLTree.minLeftCol, elseIfXMLTree.minLeftCol);
            newStackElement.maxRightCol = std::max(ifXMLTree.maxRightCol, elseIfXMLTree.maxRightCol);

            std::ostringstream _childXMLTree;

            _childXMLTree << "<IfPartOfStatement LineStart=\"" << ifXMLTree.startLine << "\" ";
            _childXMLTree << "LineEnd=\"" << ifXMLTree.endLine << "\" ";
            _childXMLTree << "MinLeftCol=\"" << ifXMLTree.minLeftCol << "\" ";
            _childXMLTree << "MaxRightCol=\"" << ifXMLTree.maxRightCol << "\" >" << std::endl;
            _childXMLTree << ifXMLTree.id;
            _childXMLTree << "</IfPartOfStatement>" << std::endl;
            _childXMLTree << "<ElsePartOfStatement LineStart=\"" << elseIfXMLTree.startLine << "\" ";
            _childXMLTree << "LineEnd=\"" << elseIfXMLTree.endLine << "\" ";
            _childXMLTree << "MinLeftCol=\"" << elseIfXMLTree.minLeftCol << "\" ";
            _childXMLTree << "MaxRightCol=\"" << elseIfXMLTree.maxRightCol << "\" >" << std::endl;
            _childXMLTree << elseIfXMLTree.id;
            _childXMLTree << "</ElsePartOfStatement>" << std::endl;

            newStackElement.id = _childXMLTree.str();
            xmlTree.pop_back();
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("FunctionBody:") == 0){
            //FunctionBody:	=> StartLine: -1 StartColumn: -1 EndLine: 22 EndColumn: 2

            stackElement FunctionBody, FunctionHeader;
            FunctionBody.tag = FUNCTION_BODY;

            stackElement lastElement;
            lastElement = xmlTree.back();


            FunctionBody.startLine = lastElement.startLine;
            FunctionBody.endLine = lastElement.endLine;
            FunctionBody.maxRightCol = lastElement.maxRightCol;
            FunctionBody.minLeftCol = lastElement.minLeftCol;

            std::ostringstream childXMLTree;

            childXMLTree << "<CompoundStatement LineStart=\"" << lastElement.startLine << "\" ";
            childXMLTree << "LineEnd=\"" << lastElement.endLine << "\" ";
            childXMLTree << "MinLeftCol=\"" << lastElement.minLeftCol << "\" ";
            childXMLTree << "MaxRightCol=\"" << lastElement.maxRightCol << "\" >" << std::endl;
            childXMLTree << lastElement.id;
            childXMLTree << "</CompoundStatement>" << std::endl;
            xmlTree.pop_back();

            FunctionHeader = xmlTree.back();

            FunctionBody.id = childXMLTree.str();



            newStackElement.tag = FUNCTION;
            newStackElement.startLine = FunctionHeader.startLine;
            newStackElement.endLine = FunctionBody.endLine;
            newStackElement.minLeftCol = std::min(FunctionHeader.minLeftCol, FunctionBody.minLeftCol);
            newStackElement.maxRightCol = std::max(FunctionHeader.maxRightCol, FunctionBody.maxRightCol);

            std::ostringstream _childXMLTree;

            _childXMLTree << "<FunctionHeader LineStart=\"" << FunctionHeader.startLine << "\" ";
            _childXMLTree << "LineEnd=\"" << FunctionHeader.endLine << "\" ";
            _childXMLTree << "MinLeftCol=\"" << FunctionHeader.minLeftCol << "\" ";
            _childXMLTree << "MaxRightCol=\"" << FunctionHeader.maxRightCol << "\" >" << std::endl;
            _childXMLTree << FunctionHeader.id;
            _childXMLTree << "</FunctionHeader>" << std::endl;
            _childXMLTree << "<FunctionBody LineStart=\"" << FunctionBody.startLine << "\" ";
            _childXMLTree << "LineEnd=\"" << FunctionBody.endLine << "\" ";
            _childXMLTree << "MinLeftCol=\"" << FunctionBody.minLeftCol << "\" ";
            _childXMLTree << "MaxRightCol=\"" << FunctionBody.maxRightCol << "\" >" << std::endl;
            _childXMLTree << FunctionBody.id;
            _childXMLTree << "</FunctionBody>" << std::endl;


            newStackElement.id = _childXMLTree.str();
            xmlTree.pop_back();
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("ForStartStatement:") == 0){
            //ForStartStatement:	=> StartLine: 10 StartColumn: 5
            newStackElement.tag = FOR_TOKEN;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.startLine = integer;
            newStackElement.endLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.minLeftCol = integer;
            newStackElement.maxRightCol = integer + 2;
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("ForHeader:") == 0){
            //Assuming there are no assignment statements inside the if condition
            //ForHeader:	=> EndLine: 10 EndColumn: 28

            newStackElement.tag = FOR_HEADER;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.endLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            std::vector<stackElement> tempXMLTree;
            stackElement lastElement;
            int min = 100000000, max = integer;

            while(1){
                if(xmlTree.empty()) break;
                lastElement = xmlTree.back();

                if(lastElement.minLeftCol < min){
                    min = lastElement.minLeftCol;
                }

                if(lastElement.maxRightCol > max){
                    max = lastElement.maxRightCol;
                }

                if(lastElement.tag != FOR_TOKEN){
                    tempXMLTree.push_back(lastElement);
                    xmlTree.pop_back();
                }
                else{
                    newStackElement.startLine = lastElement.startLine;
                    xmlTree.pop_back();
                    break;
                }

            }
            newStackElement.minLeftCol = min;
            newStackElement.maxRightCol = max;

            std::ostringstream childXMLTree;
            std::reverse(tempXMLTree.begin(), tempXMLTree.end());

            for (std::vector<stackElement>::iterator i = tempXMLTree.begin(); i != tempXMLTree.end(); i++) {
                childXMLTree << "<Token LineStart=\"" << i->startLine << "\" ";
                childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                childXMLTree << "Index=\"" << i->indexInLine << "\" ";
                childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" > " << i->id << " </Token>" << std::endl;
            }
            newStackElement.id = childXMLTree.str();
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("ForEndStatement:") == 0){
            //ForEndStatement:	=> EndLine: 12 EndColumn: 6

            newStackElement.tag = FOR_LOOP;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.endLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;

            std::vector<stackElement> tempXMLTree;
            stackElement lastElement;
            int min = 100000000, max = integer;

            while(1){
                if(xmlTree.empty()) break;
                lastElement = xmlTree.back();

                if(lastElement.minLeftCol < min){
                    min = lastElement.minLeftCol;
                }

                if(lastElement.maxRightCol > max){
                    max = lastElement.maxRightCol;
                }
                tempXMLTree.push_back(lastElement);

                if(lastElement.tag == FOR_HEADER){
                    newStackElement.startLine = lastElement.startLine;
                    xmlTree.pop_back();
                    break;
                }
                else{
                    xmlTree.pop_back();
                }

            }

            newStackElement.minLeftCol = min;
            newStackElement.maxRightCol = max;

            std::ostringstream childXMLTree;
            std::reverse(tempXMLTree.begin(), tempXMLTree.end());

            for (std::vector<stackElement>::iterator i = tempXMLTree.begin(); i != tempXMLTree.end(); i++) {
                switch(i->tag){
                    case TOKEN: {
                        childXMLTree << "<Token LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "Index=\"" << i->indexInLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" > " << i->id << " </Token>" << std::endl;
                        break;
                    }
                    case COMPOUND_STATEMENT: {
                        childXMLTree << "<CompoundStatement LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</CompoundStatement>" << std::endl;
                        break;
                    }
                    case EXPRESSION_STATEMENT: {
                        childXMLTree << "<ExpressionStatement LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</ExpressionStatement>" << std::endl;
                        break;
                    }
                    case FOR_LOOP: {
                        childXMLTree << "<ForLoop LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</ForLoop>" << std::endl;
                        break;
                    }
                    case IF_CONDITION: {
                        childXMLTree << "<IfCondition LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</IfCondition>" << std::endl;
                        break;
                    }
                    case WHILE_LOOP: {
                        childXMLTree << "<WhileLoop LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</WhileLoop>" << std::endl;
                        break;
                    }
                    case FOR_HEADER: {
                        childXMLTree << "<ForHeader LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</ForHeader>" << std::endl;
                        break;
                    }
                }

            }
            newStackElement.id = childXMLTree.str();
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("WhileStatementStart:") == 0){
            // WhileStatement:	=> StartLine: 14 StartColumn: 9
            newStackElement.tag = WHILE_TOKEN;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.startLine = integer;
            newStackElement.endLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.minLeftCol = integer;
            newStackElement.maxRightCol = integer + 4;
            xmlTree.push_back(newStackElement);
        }
        else if(tagType.compare("WhileHeader:") == 0){
            // WhileHeader:	=> EndLine: 14 EndColumn: 24
            newStackElement.tag = WHILE_HEADER;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.endLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;

            std::vector<stackElement> tempXMLTree;
            stackElement lastElement;
            int min = 100000000, max = integer;

            while(1){
                if(xmlTree.empty()) break;
                lastElement = xmlTree.back();

                if(lastElement.minLeftCol < min){
                    min = lastElement.minLeftCol;
                }

                if(lastElement.maxRightCol > max){
                    max = lastElement.maxRightCol;
                }

                if(lastElement.tag != WHILE_TOKEN){
                    tempXMLTree.push_back(lastElement);
                    xmlTree.pop_back();
                }
                else{
                    newStackElement.startLine = lastElement.startLine;
                    xmlTree.pop_back();
                    break;
                }
            }
            newStackElement.minLeftCol = min;
            newStackElement.maxRightCol = max;

            std::ostringstream childXMLTree;
            std::reverse(tempXMLTree.begin(), tempXMLTree.end());

            for (std::vector<stackElement>::iterator i = tempXMLTree.begin(); i != tempXMLTree.end(); i++) {
                childXMLTree << "<Token LineStart=\"" << i->startLine << "\" ";
                childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                childXMLTree << "Index=\"" << i->indexInLine << "\" ";
                childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" > " << i->id << " </Token>" << std::endl;
            }
            newStackElement.id = childXMLTree.str();
            xmlTree.push_back(newStackElement);

        }
        else if(tagType.compare("WhileStatementEnd:") == 0){
            // WhileStatement:	=> EndLine: 22 EndColumn: 10

            newStackElement.tag = WHILE_LOOP;
            currentLineBuffer >> skipInput >> skipInput;
            currentLineBuffer >> integer;
            newStackElement.endLine = integer;
            currentLineBuffer >> skipInput;
            currentLineBuffer >> integer;

            std::vector<stackElement> tempXMLTree;
            stackElement lastElement;
            int min = 100000000, max = integer;

            while(1){
                if(xmlTree.empty()) break;
                lastElement = xmlTree.back();

                if(lastElement.minLeftCol < min){
                    min = lastElement.minLeftCol;
                }

                if(lastElement.maxRightCol > max){
                    max = lastElement.maxRightCol;
                }
                tempXMLTree.push_back(lastElement);

                if(lastElement.tag == WHILE_HEADER){
                    newStackElement.startLine = lastElement.startLine;
                    xmlTree.pop_back();
                    break;
                }
                else{
                    xmlTree.pop_back();
                }

            }

            newStackElement.minLeftCol = min;
            newStackElement.maxRightCol = max;

            std::ostringstream childXMLTree;
            std::reverse(tempXMLTree.begin(), tempXMLTree.end());

            for (std::vector<stackElement>::iterator i = tempXMLTree.begin(); i != tempXMLTree.end(); i++) {
                switch(i->tag){
                    case TOKEN: {
                        childXMLTree << "<Token LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "Index=\"" << i->indexInLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" > " << i->id << " </Token>" << std::endl;
                        break;
                    }
                    case COMPOUND_STATEMENT: {
                        childXMLTree << "<CompoundStatement LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</CompoundStatement>" << std::endl;
                        break;
                    }
                    case EXPRESSION_STATEMENT: {
                        childXMLTree << "<ExpressionStatement LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</ExpressionStatement>" << std::endl;
                        break;
                    }
                    case FOR_LOOP: {
                        childXMLTree << "<ForLoop LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</ForLoop>" << std::endl;
                        break;
                    }
                    case IF_CONDITION: {
                        childXMLTree << "<IfCondition LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</IfCondition>" << std::endl;
                        break;
                    }
                    case WHILE_LOOP: {
                        childXMLTree << "<WhileLoop LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</WhileLoop>" << std::endl;
                        break;
                    }
                    case WHILE_HEADER: {
                        childXMLTree << "<WhileHeader LineStart=\"" << i->startLine << "\" ";
                        childXMLTree << "LineEnd=\"" << i->endLine << "\" ";
                        childXMLTree << "MinLeftCol=\"" << i->minLeftCol << "\" ";
                        childXMLTree << "MaxRightCol=\"" << i->maxRightCol << "\" >" << std::endl;
                        childXMLTree << i->id;
                        childXMLTree << "</WhileHeader>" << std::endl;
                        break;
                    }
                }

            }
            newStackElement.id = childXMLTree.str();
            xmlTree.push_back(newStackElement);
        }
        // std::cout << "Loop no :" << liner << std::endl;
        // for (std::vector<stackElement>::iterator it = xmlTree.begin(); it != xmlTree.end(); it++) {
        //     std::cout << "tag id: " << it->tag << std::endl;
        //     if(it->tag == TOKEN){
        //         std::cout << "id = " << it->id << std::endl;
        //     }
        //
        // }
        // std::cout << std::endl;
    }

    makeXML();
    return 0;
}
